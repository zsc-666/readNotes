# MySql 逻辑架构
第一层：客户端，包含连接处理，身份验证、确保安全性等
第二层：包含核心功能，查询解析、分析、优化、以及所有内置函数。
第三层：存储引擎层。负责 Mysql 数据的存储和提取

![[MySQL 服务器架构的逻辑视图.png]]

## 连接管理与安全性
每个客户端连接会在服务器拥有一个线程，该线程在一个内核或CPU上。服务器维护一个缓存区用来存放已就绪的线程，不需要为每个新的连接创建或销毁线程。

当客户端连接Mysql的时候，要进行身份验证。身份验证基于用户名，发起的主机名和密码。如果以跨传输层安全（TLS）的方式连接。可以使用 X.509 证书。连接后验证客户端是否具有查询的权限

## 优化与执行
MySQL 解析查询以创建内部数据结构（解析树），对其进行各种优化。重写查询、决定表的读取顺序、以及选择合适的索引。

## 并发控制
处理并发控制 实现一个由两种锁类型组成的锁系统。共享锁 和 排他锁。也叫读锁和写锁。

读锁： 资源上的读锁是共享的，或者说是相互不阻塞的。多个客户端可以同时读取同一个资源互不干扰。
写锁： 写锁是排他的。一个写锁既会阻塞读锁也会阻塞其他写锁。出于安全考虑。

## 锁的粒度
一种提高共享资源并发性的方式让锁定对象更有选择性，尽量只锁定包含修改的部分数据，而不是所有资源。更理想的方式是，对需要修改的数据片段进行精确的锁定。
加锁也需要消耗资源。锁的各种操作，包括获取锁、检查锁是否空闲、释放锁等。会增加开销。如果花费大量时间管理锁而不是存放数据，则系统可能会受影响。
锁定策略是锁开销和数据安全性之间的平衡。
大多数数据库一般是在表中施加行级锁（row level lock），但是 MYSQL 提供多种选择。每种 MYSQL 存储引擎都可以实现自己的锁策略和锁粒度。
### 表锁
开销最小的锁策略，锁定整张表。
### 行锁
使用行级锁（row lock）最大程度地支持并发处理，需要更大的开销（跟踪谁拥有了这些行级锁、已经锁定多长时间、行级锁的类型、以及何时该清理不需要的行级锁）。

行级锁是在存储引擎而不是服务器中实现的。

## 事务
作为事务的一组语句，要么全部执行成功，要么全部不成功。

atomicity
一个事务必须被视为一个不可分割的工作单元，要么全部成功，要么全部失败

consistency
如果事务最终没有提交，该事务做的任何修改都不会被保存到数据库中

isolation
一个事务最终提交以前，其他事务不可见

持久性
一旦提交，事务做的修改永久保存到数据库中

## 隔离级别
READ UNCOMMITTED （未提交读）
在事务中可以查看其他事务中还没有提交的修改。实际上很少使用。
读取到未提交的数据，也称为脏读。
例子：第一个事务正在修改数据 ，第二个事务读到该数据修改后的数据，结果第一个事务取消，第二个事务读到修改前的数据，导致脏读。

READ COMMITTED （提交读）
大多数数据库默认隔离级别是 READ COMMITTED 。
会出现同一事务查询两次相同语句，两次结果不同。
例子：第一个事务查询两次语句（分别在修改前后），第二个事务修改一条数据。第一个事务查询两条结果不相同。

REPEATABLE READ (可重复读)
该级别解决了不可重复读问题，保证了同一事务多次读取相同行数据的结果是一样的。
但是会出现幻读的问题。幻读：读取某个范围内的记录时，另一个事务又在该范围内插入新的记录，当之前的事务再次读取该范围的记录，会出现幻行。
InnoDB 通过多版本并发控制（MVCC） 解决幻读问题。
REPEATABLE READ 是 MYSQL 默认事务隔离级别。

SERIALIZABLE （可串行化）
强制通过事务按序执行，使不同事务之间不可能产生冲突。

## 死锁
死锁是指两个或多个事务相互持有和请求相同资源上的锁，产生了循环依赖。

![[死锁演示图.png]]
解决这个问题，实现各种死锁检测和锁超时机制。比如 InnoDB，检测到循环依赖后立即返回一个错误信息。还有一种方式，当超过锁等待超时时间的限制后直接终止查询，这样做通常来说不太好。InnoDB 目前处理死锁的方式是将持有最少行级排他锁的事务回滚（最容易回滚的近似算法）。

## 事务日志
事务日志有助于提高事务的效率。存储引起只需要更改内存中的数据副本，而不用每次修改磁盘中的表。再把更改的记录写入事务日志中（顺序I/O，速度比较快），事务日志会被持久化保存在硬盘上（有一个后台进程在某个时间去更新磁盘中的表）。
## MYSQL 中的事务
存储引擎是驱动如何从硬盘中存储和检索数据的软件。

#### 理解 AUTOCOMMIT
默认情况下，单个 INSERT、 UPDATE 或 DELETE 会被隐式包装在一个事务中并在执行成功后立即提交，这称为自动提交。

禁用此模式，可以在事务执行事务语句。

### 不推荐在事务中混合使用存储引擎

## 隐式锁定和显示锁定 
InnoDB 使用两阶段锁定协议。InnoDB 根据隔离级别自动处理锁，只有在提交或回滚才释放。这为隐式锁定。

显示锁定
SELECT ... FOR SHARE
SELECT ... FOR UPDATE

还支持 LOCK TABLES 和 UNLOCK TABLES 。除了在禁用 AUTOCOMMIT 的事务中 都别用。

## 多版本并发控制
事务性存储引擎采用  行级锁和多版本并发控制（MVCC）结合使用。
![[跨不同事务处理同一行多个版本的序列图.png]]
1、读操作，当事务执行读操作时，使用快照读取。
具体操作：
	对于读取操作，事务会找到符合版本的数据行，选择符合事务开始时间的数据版本进行读取
	对于某个数据行有多个版本，事务选择不晚于其开始时间的最新版本，确保只读取在它开始之前已经存在的数据。
	事务读取的是快照数据，因此其他并发事务对数据行的修改不会影响当前事务的读取操作
2、写操作。当一个事务执行写操作时，会生成一个新的数据版本，并将修改后的数据写入数据库。具体工作如下：
	写操作时，事务会为修改的数据行创建一个新的版本，将修改后的数据写入新版本，
	新版本的数据会带有当前事务的版本号，以便其他事务能够正确读取相应版本的数据。
	原始版本数据仍然存在，供其他事务使用快照读取。其他事务读取不受当前事务写操作影响。

3、事务提交和回滚：
	当一个事务提交时，它所做的修改将成为数据库的最新版本，并对其他事务可见。
	当一个事务回滚时，它所做的修改将会被撤销，对其他事务不可见。

4、版本回收
	MVCC 会定期进行版本的回收。回收机制会删除不再需要的旧版本数据，来释放空间。

MVCC 通过创建数据库多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，确保原始版本可用。这样不同的事务在一定程度上能偶并发执行，不会互相干扰，提高了数据库的并发性能和数据一致性。


## 一致性非锁定读和锁定读
#### 一致性非锁定读
一致性非锁定读的实现，通常是加一个版本号或时间戳。查询时将当前可见版本号与对应记录的版本号进行对比，如果记录的版本小于可见版本，则表示该记录可见。

InnoDB 中，多版本控制就是对非锁定读的实现。 对于读取历史数据的方式，我们叫他快照读。

#### 锁定读
select ... lock in share mode  
对记录加 S 锁，其他事务也能加S锁。如果加 X 锁则会被阻塞
select ... for update
insert、update、delete
对记录加 X 锁，其它事务不能加任何锁。

锁定读下，读取的是最新版本。锁定读会对读取到的记录加锁。

在一致性非锁定读下，即使记录被加上 X 锁，也是能被读取的。
Repetable Read 防止 MVCC 部分幻读。如果两次查询中间有其它事务插入数据，会产生幻读。
InnoDB 在实现 Repetable Read 时，如果执行的是当前读，则会对读取的记录使用 Next-key Lock，以防止其它事务在间隙间插入数据。

## InnoDB 对 MVCC 的实现
MVCC 实现依赖于：隐藏字段、Read View、undo log。
#### 隐藏字段
InnoDB 存储引擎为每行数据添加三个隐藏字段：
DB_TRX_ID(6字节): 表示最后一次插入或更新该行的事务id。delete 视为更为更新 记录头 Record header 中 deleted_flag 字段标记为已删除。
DB_ROLL_PIR(7字节): 回滚指针，指向该行的 undo log。如果该行未被更新，则为空
DB_ROW_ID(6字节)：如果没有设置主键且该表没有唯一非空索引时，InnoDB 会使用 id 来生成聚簇索引。

#### ReadView
```
class ReadView {
  /* ... */
private:
  trx_id_t m_low_limit_id;      /* 大于等于这个 ID 的事务均不可见 */

  trx_id_t m_up_limit_id;       /* 小于这个 ID 的事务均可见 */

  trx_id_t m_creator_trx_id;    /* 创建该 Read View 的事务ID */

  trx_id_t m_low_limit_no;      /* 事务 Number, 小于该 Number 的 Undo Logs 均可以被 Purge */

  ids_t m_ids;                  /* 创建 Read View 时的活跃事务列表 */

  m_closed;                     /* 标记 Read View 是否 close */
}
```
Read View 主要用来做可见性判断，保存了"当前对本事务不可见的其他活跃事务"
![[事务可见性示意图.png]]
#### undo-log
undo log 主要有两个作用
	事务回滚时将数据恢复到修改前的样子
	MVCC 当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则通过 undo log 读取之前的版本数据，以此来实现非锁定读

在 InnoDB 存储引擎中 undo log 分为 insert undo log 和 update undo log：
1、insert undo log：在 insert 操作中产生的 undo log。只对本身可见，undo log 在提交后直接删除。不需要 purge

2、update undo log： update 或 delete 操作产生的 undo log。需要提供 MVCC 机制，需要放到 undo log 链表中，等待 purge 线程进行最后的删除。


## 数据可见性算法
在 InnoDB 存储引擎中，创建一个新事务后，每个执行 select 语句前，都会创建一个快照，快照中保存了当前数据库系统中正处于活跃的事务ID号（即m_ids）。
![[数据可见性算法.png]]

RC 和 RR 隔离级别下 MVCC 的差异
在 RC 隔离级别下 每次 select 查询生成一个 Read View
在 RR 隔离级别下 第一次 select 生成一个 Read View


#### `InnoDB`存储引擎在 RR 级别下通过 `MVCC`和 `Next-key Lock` 来解决幻读问题

## 复制
MYSQl 提供一种原生方式将一个节点执行的写操作分发到其他节点，这被称为复制。
![[MYSQL服务器复制拓扑的简化视图.png]]
在生产环境中运行的任何数据，都应该使用复制并至少有三个以上的副本，理想情况下应该分布到不同地区用于灾难恢复。

## 数据文件结构
在 8.0 MYSQL 将表的元数据重新设计为一种数据字典，包含在表的 .ibd文件中。使得表结构上的信息支持事务和原子级数据定义更改。
不再依赖 information_schema 来检索表定义和元数据，引入字典对象缓存，基于最近最少使用（LRU）的内存缓存，包括分区定义、表定义、存储程序定义、字符集和排序信息。  这一变化减少了 I/O，非常高效。特别是当前访问最活跃的那些表，在缓存中最常出现。每个表.idb和.frm 文件被替换为已经序列化的字典信息（.sdi）

## InnoDB 引擎
- InnoDB 是MySQL 默认的通用存储引擎。
- InnoDB 使用 MVCC 来实现高并发性，实现 4 个 SQL 标准隔离级别。 InnoDB 默认为 REPEATABLE READ 隔离级别，并通过间隙锁（next-key locking）策略防止在这个隔离级别上的幻读：锁定查询中涉及的行，还对索引结构中的间隙进行锁定，防止幻行被插入。
- InnoDB 是聚簇索引构建的。聚簇索引提供非常快速的主键查找。但是，因为二级索引（secondary index，非主键索引）需要包含主键列，如果主键较大，其他索引也会很大。如果表中索引较多，主键应该足够小。
- InnoDB 内部做了很多优化。包括从磁盘预取数据的可预测性预读，自动在内存中构建哈希索引以快速查找自适应哈希索引，用于快速插入操作的插入缓冲区。
- InnoDB 行为复杂。由于其 MVCC 架构，在使用 InnoDB 构建应用程序之前，需要注意。
- InnoDB 可以通过一些机制和工具实现真正的在线"热"备份
- MSQL 5.6 开始，InnoDB 引入在线 DDL 。能够在线更改 schema 的选项

## JSON 文档支持
JSON 类型在 5.7 版本中首次引入 Inno DB，实现了 JSON 文档的自动验证，优化存储以快速读取。这是旧版本使用 BLOB 来处理 JSON 文档作为折中的重大改进。

## 数据字典的变化
MySQL 8.0 的另一个变化 删除了基于文件的表元数据存储，并转移到 InnoDB 表存储的数据字典中。给所有类似修改表结构的操作带来了 InnoDB 崩溃恢复事务的好处。

## 原子 DDL 
数据定义语句现在是要么全部成功，要么全部失败回滚。通过创建 DDL 特定的 Undo log 和 Redo logo 实现。


